<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Interior & Exterior Angles - Triangles</title>
<style>
  :root {
    --red: #C51D34;
    --charcoal: #2E2E30;
    --gray: #808080;
    --offwhite: #F5F5F5;
  }

  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: var(--offwhite);
    color: var(--charcoal);
  }

  header {
    background: var(--charcoal);
    color: var(--offwhite);
    padding: 10px 20px;
    text-align: center;
  }

  h1 { margin: 0; font-size: 1.4rem; }

  main {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    padding: 20px;
    justify-content: flex-start;
    align-items: flex-start;
    width: 100%;
    box-sizing: border-box;
  }

  #canvas-container {
    flex: 0 0 auto;
    min-width: 500px;
    background: white;
    border: 4px solid var(--gray);
    border-radius: 8px;
    padding: 10px;
    position: relative;
    margin: 0 auto;
    width: fit-content;
  }

  #controls {
    margin-top: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    font-size: 0.9rem;
    max-width: 100%;
  }

  .video-btn {
    background-color: #c41524;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 10px 50px;
    font-size: 16px;
    cursor: pointer;
    margin-right: 0px;
    font-weight: bold;
  }

  button {
    border-radius: 4px;
    border: none;
    padding: 6px 10px;
    cursor: pointer;
    background: var(--red);
    color: var(--offwhite);
    flex: 0 1 calc(33.333% - 6px);
    min-width: 100px;
    height: 40px;
    box-sizing: border-box;
  }

  button.secondary { background: var(--gray); }

  #info-panel {
    flex: none;
    min-width: 260px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .card {
    background: white;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 0 4px rgba(0,0,0,0.15);
  }

  .card h2 {
    margin: 0 0 4px;
    font-size: 1.1rem;
    color: var(--red);
  }

  .definition { font-size: 0.9rem; }

  .vocab-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 8px;
    margin-top: 6px;
  }

  .vocab-term {
    border-left: 5px solid var(--red);
    padding-left: 6px;
    font-size: 0.9rem;
  }

  #angle-output { font-size: 0.9rem; margin-top: 4px; }

  .legend {
    font-size: 0.85rem;
    margin-top: 4px;
  }

  .legend span {
    display: inline-block;
    margin-right: 8px;
  }

  .dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 3px;
  }

  .manip-row {
    display: flex;
    align-items: flex-start;
    justify-content: center;
    gap: 20px;
    width: 100%;
    box-sizing: border-box;
    position: relative;
  }

  .right-column {
    position: absolute;
    top: 12px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
    justify-content: center;
    width: max-content;
  }

  #ixlBtn {
    background: #2ECC40;
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    text-decoration: none;
    display: block;
    width: 100%;
    box-sizing: border-box;
    text-align: center;
  }

  #ixlBtn:hover { background: #27AE60; }

  #videosBtn {
    background: var(--red);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 4px;
    text-decoration: none;
    font-weight: bold;
    display: block;
    width: 100%;
    box-sizing: border-box;
    text-align: center;
  }

  #videosBtn:hover { background: #A01829; }

  /* === Triangle manipulative styles === */

  svg#board { border: 1px solid #ccc; touch-action: none; }

  .edge { stroke: #000; stroke-width: 6; fill: none; stroke-linecap: round; }
  .ray  { stroke: #000; stroke-width: 6; fill: none; marker-end: url(#arrow); }
  .handle { fill: red; cursor: pointer; }
  .fixed-point { fill: #004c7f; }

  .angle-label {
    font-family: system-ui, sans-serif;
    font-size: 18px;
    font-weight: 700;
    fill: #333;
    text-anchor: middle;
    dominant-baseline: middle;
    pointer-events: none;
    user-select: none;
  }

  .angle-arc { stroke-width: 6; fill: none; }

  .angle-left        { stroke: #0077b6; }
  .angle-top         { stroke: #00a676; }
  .angle-right-int   { stroke: #ffb703; }
  .angle-right-ext-top  { stroke: #00a676; }
  .angle-right-ext-left { stroke: #0077b6; }

  /* label colors */
  .label-left           { fill: #0077b6; }
  .label-top            { fill: #00a676; }
  .label-right-int      { fill: #ffb703; }
  .label-right-ext-top  { fill: #00a676; }
  .label-right-ext-left { fill: #0077b6; }

  .equation-label { font-size: 20px; }
</style>
</head>
<body>
<header>
  <h1>Interior & Exterior Angles of a Triangle</h1>
</header>

<main>
  <div class="manip-row">
    <section id="canvas-container">

      <!-- === Triangle SVG manipulative === -->
      <svg id="board" width="900" height="500" viewBox="0 0 900 500">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
            <path d="M0,0 L10,3 L0,6 z" fill="#000" />
          </marker>
        </defs>

        <!-- Angle slices behind triangle -->
        <path id="angleLeftInterior"   class="angle-arc angle-left"></path>
        <path id="angleTopInterior"    class="angle-arc angle-top"></path>
        <path id="angleRightInterior"  class="angle-arc angle-right-int"></path>
        <path id="angleRightExteriorTop"   class="angle-arc angle-right-ext-top"></path>
        <path id="angleRightExteriorLeft"  class="angle-arc angle-right-ext-left"></path>

        <!-- Angle labels -->
        <text id="labelLeft"    class="angle-label label-left"></text>
        <text id="labelTop"     class="angle-label label-top"></text>
        <text id="labelRight"   class="angle-label label-right-int"></text>
        <text id="labelExtTop"  class="angle-label label-right-ext-top"></text>
        <text id="labelExtLeft" class="angle-label label-right-ext-left"></text>

        <!-- Equation along left side -->
        <text id="equationLabel" class="angle-label equation-label">
          <tspan id="eqSideLeft" class="label-left"></tspan>
          <tspan> + </tspan>
          <tspan id="eqSideTop" class="label-top"></tspan>
          <tspan> = </tspan>
          <tspan id="eqSideSum"></tspan>
        </text>

        <!-- Same equation above exterior slices (top + left) -->
        <text id="equationLabelTop" class="angle-label equation-label">
          <tspan id="eqTopTop"  class="label-top"></tspan>
          <tspan> + </tspan>
          <tspan id="eqTopLeft" class="label-left"></tspan>
          <tspan> = </tspan>
          <tspan id="eqTopSum"></tspan>
        </text>

        <!-- Center equation: all three interior angles -->
        <text id="equationCenter" class="angle-label equation-label">
          <tspan id="eqCenterLeft"  class="label-left"></tspan>
          <tspan> + </tspan>
          <tspan id="eqCenterTop"   class="label-top"></tspan>
          <tspan> + </tspan>
          <tspan id="eqCenterRight" class="label-right-int"></tspan>
          <tspan> = </tspan>
          <tspan id="eqCenterSum"></tspan>
        </text>

        <!-- Bottom equation: right interior + two exterior congruent slices -->
        <text id="equationBottom" class="angle-label equation-label">
          <tspan id="eqBottomRight"   class="label-right-int"></tspan>
          <tspan> + </tspan>
          <tspan id="eqBottomExtTop"  class="label-right-ext-top"></tspan>
          <tspan> + </tspan>
          <tspan id="eqBottomExtLeft" class="label-right-ext-left"></tspan>
          <tspan> = </tspan>
          <tspan id="eqBottomSum"></tspan>
        </text>

        <!-- Base ray (static) -->
        <line id="baseRay" class="edge" x1="100" y1="420" x2="800" y2="420" marker-end="url(#arrow)"></line>

        <!-- Triangle edges -->
        <polyline id="triangle" class="edge" points=""></polyline>

        <!-- Draggable triangle vertices -->
        <!-- Left vertex is implicit at (100,420), no handle shown -->
        <circle id="B" class="handle" r="9" cx="450" cy="120"></circle>  <!-- top vertex -->
        <circle id="C" class="handle" r="9" cx="600" cy="420"></circle>  <!-- right vertex on base -->
      </svg>

      <!-- You can repurpose controls/legend if desired -->
      <div id="controls">
        <!-- Example: no buttons yet; add later if needed -->
      </div>

      <div class="legend">
      </div>

      <div id="angle-output">
        Instructions: Drag the red vertices to explore angle relationships.
      </div>

    </section>

<div class="right-column">
  <a id="ixlBtn" href="/ixl-resources.html">IXL Resources</a>
  <a id="videosBtn" href="/videos.html">Videos</a>
  <a id="practiceBtn" href="/practice.html" class="video-btn">Practice</a>
</div>

  <section id="info-panel">
    <!-- keep / add any cards or text you want here -->
  </section>
</main>

<script>
const svg  = document.getElementById('board');
const tri  = document.getElementById('triangle');
const B    = document.getElementById('B'); // top
const C    = document.getElementById('C'); // right on base

const angleLeftInt      = document.getElementById('angleLeftInterior');
const angleTopInt       = document.getElementById('angleTopInterior');
const angleRightInt     = document.getElementById('angleRightInterior');
const angleRightExtTop  = document.getElementById('angleRightExteriorTop');
const angleRightExtLeft = document.getElementById('angleRightExteriorLeft');

const labelLeft   = document.getElementById('labelLeft');
const labelTop    = document.getElementById('labelTop');
const labelRight  = document.getElementById('labelRight');
const labelExtTop = document.getElementById('labelExtTop');
const labelExtLeft= document.getElementById('labelExtLeft');

const equationLabel     = document.getElementById('equationLabel');
const equationLabelTop  = document.getElementById('equationLabelTop');
const equationCenter    = document.getElementById('equationCenter');
const equationBottom    = document.getElementById('equationBottom');

// tspans for equations
const eqSideLeft   = document.getElementById('eqSideLeft');
const eqSideTop    = document.getElementById('eqSideTop');
const eqSideSum    = document.getElementById('eqSideSum');

const eqTopLeft    = document.getElementById('eqTopLeft');
const eqTopTop     = document.getElementById('eqTopTop');
const eqTopSum     = document.getElementById('eqTopSum');

const eqCenterLeft  = document.getElementById('eqCenterLeft');
const eqCenterTop   = document.getElementById('eqCenterTop');
const eqCenterRight = document.getElementById('eqCenterRight');
const eqCenterSum   = document.getElementById('eqCenterSum');

const eqBottomRight   = document.getElementById('eqBottomRight');
const eqBottomExtTop  = document.getElementById('eqBottomExtTop');
const eqBottomExtLeft = document.getElementById('eqBottomExtLeft');
const eqBottomSum     = document.getElementById('eqBottomSum');

// Fixed left base vertex
const leftBase = { x: 100, y: 420 };

// --- Geometry helpers ---
function angleBetween(p, q, r) {
  const u = { x: p.x - q.x, y: p.y - q.y };
  const v = { x: r.x - q.x, y: r.y - q.y };
  const dot = u.x * v.x + u.y * v.y;
  const mu  = Math.hypot(u.x, u.y);
  const mv  = Math.hypot(v.x, v.y);
  if (!mu || !mv) return 0;
  let cos = dot / (mu * mv);
  cos = Math.max(-1, Math.min(1, cos));
  return Math.acos(cos);
}

function polarToCartesian(center, radius, angleRad) {
  return {
    x: center.x + radius * Math.cos(angleRad),
    y: center.y + radius * Math.sin(angleRad)
  };
}

function describeArc(center, radius, startAngle, endAngle) {
  const start = polarToCartesian(center, radius, startAngle);
  const end   = polarToCartesian(center, radius, endAngle);
  const largeArcFlag = endAngle - startAngle <= Math.PI ? '0' : '1';
  return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${end.x} ${end.y}`;
}

// --- Dragging handles ---
let draggingHandle = null;

function getMousePos(evt) {
  const pt = svg.createSVGPoint();
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  const m = svg.getScreenCTM().inverse();
  return pt.matrixTransform(m);
}

// Top vertex: free drag, but not below the base ray
B.addEventListener('pointerdown', e => {
  draggingHandle = B;
  B.setPointerCapture(e.pointerId);
});
B.addEventListener('pointerup', e => {
  draggingHandle = null;
  B.releasePointerCapture(e.pointerId);
});
B.addEventListener('pointermove', e => {
  if (draggingHandle !== B) return;
  const pos = getMousePos(e);

  const maxY = leftBase.y - 5;  // just above the ray
  const minY = 20;
  const minX = 20;
  const maxX = 880;

  const clampedX = Math.min(Math.max(pos.x, minX), maxX);
  const clampedY = Math.min(Math.max(pos.y, minY), maxY);

  B.setAttribute('cx', clampedX);
  B.setAttribute('cy', clampedY);
  update();
});

// Right vertex: constrained to base line, and not past the left end
C.addEventListener('pointerdown', e => {
  draggingHandle = C;
  C.setPointerCapture(e.pointerId);
});
C.addEventListener('pointerup', e => {
  draggingHandle = null;
  C.releasePointerCapture(e.pointerId);
});
C.addEventListener('pointermove', e => {
  if (draggingHandle !== C) return;
  const pos = getMousePos(e);

  const minX = leftBase.x + 20;
  const maxX = 880;

  const clampedX = Math.min(Math.max(pos.x, minX), maxX);

  C.setAttribute('cx', clampedX);
  C.setAttribute('cy', leftBase.y);
  update();
});

function placeAngleLabel(labelEl, center, radius, startAngle, endAngle, angleRad) {
  const mid = (startAngle + endAngle) / 2;
  const r   = radius * 0.6;
  const pt  = polarToCartesian(center, r, mid);
  const degrees = Math.round(angleRad * 180 / Math.PI);
  labelEl.setAttribute('x', pt.x);
  labelEl.setAttribute('y', pt.y);
  labelEl.textContent = degrees + '°';
}

function update() {
  const pL = leftBase;
  const pB = { x: +B.getAttribute('cx'), y: +B.getAttribute('cy') };
  const pC = { x: +C.getAttribute('cx'), y: +C.getAttribute('cy') };

  // --- equation label along left side, centered and outside triangle ---
  const midLeft = {
    x: (pL.x + pB.x) / 2,
    y: (pL.y + pB.y) / 2
  };

  const vLB = { x: pB.x - pL.x, y: pB.y - pL.y };
  const theta = Math.atan2(vLB.y, vLB.x);

  const n = { x: vLB.y, y: -vLB.x };
  const lenN = Math.hypot(n.x, n.y) || 1;
  const normal = { x: n.x / lenN, y: n.y / lenN };

  const offsetSide = 40;
  const eqPos = {
    x: midLeft.x + normal.x * offsetSide,
    y: midLeft.y + normal.y * offsetSide
  };

  equationLabel.setAttribute('x', eqPos.x);
  equationLabel.setAttribute('y', eqPos.y);
  equationLabel.setAttribute(
    'transform',
    `rotate(${theta * 180 / Math.PI}, ${eqPos.x}, ${eqPos.y})`
  );

  // triangle
  tri.setAttribute('points', `${pL.x},${pL.y} ${pB.x},${pB.y} ${pC.x},${pC.y}`);

  // angles at vertices (radians)
  const angleLeft  = angleBetween(pB, pL, pC);
  const angleTop   = angleBetween(pL, pB, pC);
  const angleRight = angleBetween(pL, pC, pB);

  // convert to degrees once; adjust right so sum is exactly 180
  const leftDeg  = Math.round(angleLeft * 180 / Math.PI);
  const topDeg   = Math.round(angleTop  * 180 / Math.PI);
  const rightDeg = 180 - leftDeg - topDeg;

  // ----- side equation (left + top) -----
  const sideSum = leftDeg + topDeg;
  eqSideLeft.textContent = `${leftDeg}°`;
  eqSideTop.textContent  = `${topDeg}°`;
  eqSideSum.textContent  = `${sideSum}°`;

  // ----- same equation above exterior slices (top + left) -----
  eqTopTop.textContent  = `${topDeg}°`;
  eqTopLeft.textContent = `${leftDeg}°`;
  eqTopSum.textContent  = `${sideSum}°`;

  const offsetUp    = 120;
  const offsetRight = 70;
  equationLabelTop.setAttribute('x', pC.x + offsetRight);
  equationLabelTop.setAttribute('y', pC.y - offsetUp);
  equationLabelTop.removeAttribute('transform');

  // ----- center equation: all three interior angles -----
  const sumAllDeg = leftDeg + topDeg + rightDeg;
  eqCenterLeft.textContent  = `${leftDeg}°`;
  eqCenterTop.textContent   = `${topDeg}°`;
  eqCenterRight.textContent = `${rightDeg}°`;
  eqCenterSum.textContent   = `${sumAllDeg}°`;

  const centroid = {
    x: (pL.x + pB.x + pC.x) / 3,
    y: (pL.y + pB.y + pC.y) / 3
  };
  equationCenter.setAttribute('x', centroid.x);
  equationCenter.setAttribute('y', centroid.y);
  equationCenter.removeAttribute('transform');

  // ----- bottom equation: right interior + two exterior congruent slices -----
  const extTopDeg   = topDeg;
  const extLeftDeg  = leftDeg;
  const extRightDeg = 180 - extTopDeg - extLeftDeg;
  const sumBottom   = extRightDeg + extTopDeg + extLeftDeg;

  eqBottomRight.textContent   = `${extRightDeg}°`;
  eqBottomExtTop.textContent  = `${extTopDeg}°`;
  eqBottomExtLeft.textContent = `${extLeftDeg}°`;
  eqBottomSum.textContent     = `${sumBottom}°`;

  const offsetDown = 40;
  equationBottom.setAttribute('x', pC.x);
  equationBottom.setAttribute('y', pC.y + offsetDown);
  equationBottom.removeAttribute('transform');

  // ----- interior at LEFT vertex (slice) -----
  const rL  = 100;
  const vLC = { x: pC.x - pL.x, y: pC.y - pL.y };
  let startL = Math.atan2(vLB.y, vLB.x);
  let endL   = Math.atan2(vLC.y, vLC.x);

  const arcL     = describeArc(pL, rL, startL, endL);
  const startPtL = polarToCartesian(pL, rL, startL);
  const endPtL   = polarToCartesian(pL, rL, endL);
  const sliceL   = `
    M ${pL.x} ${pL.y}
    L ${startPtL.x} ${startPtL.y}
    ${arcL}
    L ${pL.x} ${pL.y}
  `;
  angleLeftInt.setAttribute('d', sliceL.trim());
  placeAngleLabel(labelLeft, pL, rL, startL, endL, angleLeft);

  // ----- interior at TOP vertex (slice) -----
  const rT  = 100;
  const vTB = { x: pL.x - pB.x, y: pL.y - pB.y };
  const vTC = { x: pC.x - pB.x, y: pC.y - pB.y };
  let startT = Math.atan2(vTC.y, vTC.x);
  let endT   = Math.atan2(vTB.y, vTB.x);

  const arcT     = describeArc(pB, rT, startT, endT);
  const startPtT = polarToCartesian(pB, rT, startT);
  const endPtT   = polarToCartesian(pB, rT, endT);
  const sliceT   = `
    M ${pB.x} ${pB.y}
    L ${startPtT.x} ${startPtT.y}
    ${arcT}
    L ${pB.x} ${pB.y}
  `;
  angleTopInt.setAttribute('d', sliceT.trim());
  placeAngleLabel(labelTop, pB, rT, startT, endT, angleTop);

  // ----- interior at RIGHT vertex (slice) -----
  const rR  = 100;
  const vRC = { x: pL.x - pC.x, y: pL.y - pC.y };
  const vRB = { x: pB.x - pC.x, y: pB.y - pC.y };
  let startR = Math.atan2(vRC.y, vRC.x);
  let endR   = Math.atan2(vRB.y, vRB.x);

  const arcR     = describeArc(pC, rR, startR, endR);
  const startPtR = polarToCartesian(pC, rR, startR);
  const endPtR   = polarToCartesian(pC, rR, endR);
  const sliceR   = `
    M ${pC.x} ${pC.y}
    L ${startPtR.x} ${startPtR.y}
    ${arcR}
    L ${pC.x} ${pC.y}
  `;
  angleRightInt.setAttribute('d', sliceR.trim());

  const midR    = (endR + startR) / 2 + Math.PI;
  const rLabelR = rR * 0.6;
  const labelPtR= polarToCartesian(pC, rLabelR, midR);
  labelRight.setAttribute('x', labelPtR.x);
  labelRight.setAttribute('y', labelPtR.y);
  labelRight.textContent = `${rightDeg}°`;

  // ----- exterior at RIGHT vertex split into two slices -----
  const extRadius = 100;
  const ext1Angle = angleTop;
  const ext2Angle = angleLeft;

  const extStart1 = endR;
  const extEnd1   = extStart1 + ext1Angle;

  const extStart2 = extEnd1;
  const extEnd2   = extStart2 + ext2Angle;

  // slice 1 (top-congruent)
  const arcExt1     = describeArc(pC, extRadius, extStart1, extEnd1);
  const startPtExt1 = polarToCartesian(pC, extRadius, extStart1);
  const endPtExt1   = polarToCartesian(pC, extRadius, extEnd1);
  const sliceExt1   = `
    M ${pC.x} ${pC.y}
    L ${startPtExt1.x} ${startPtExt1.y}
    ${arcExt1}
    L ${pC.x} ${pC.y}
  `;
  angleRightExtTop.setAttribute('d', sliceExt1.trim());
  placeAngleLabel(labelExtTop, pC, extRadius, extStart1, extEnd1, angleTop);

  // slice 2 (left-congruent)
  const arcExt2     = describeArc(pC, extRadius, extStart2, extEnd2);
  const startPtExt2 = polarToCartesian(pC, extRadius, extStart2);
  const endPtExt2   = polarToCartesian(pC, extRadius, extEnd2);
  const sliceExt2   = `
    M ${pC.x} ${pC.y}
    L ${startPtExt2.x} ${startPtExt2.y}
    ${arcExt2}
    L ${pC.x} ${pC.y}
  `;
  angleRightExtLeft.setAttribute('d', sliceExt2.trim());
  placeAngleLabel(labelExtLeft, pC, extRadius, extStart2, extEnd2, angleLeft);
}

// initial draw
update();
</script>
</body>
</html>
